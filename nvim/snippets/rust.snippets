snippet fn "function"
	fn ${1}(${2})${3} {
		${0}
	}

snippet pfn "pub function"
	pub fn ${1}(${2})${3} {
		${0}
	}

snippet afn "async function"
	async fn ${1}(${2})${3} {
		${0}
	}

snippet pafn "pub async function"
	pub async fn ${1}(${2})${3} {
		${0}
	}

snippet bench "bench"
	#[bench]
	fn ${1}(b: &mut test::Bencher) {
		b.iter(|| {
			${0}
		})
	}

snippet new "new"
	pub fn new(${2}) -> ${1:Self} {
		${1} { ${3} }
	}

snippet main "main"
	pub fn main() {
		${0}
	}

snippet let "let"
	let ${1} = ${2};

snippet lett "let typed"
	let ${1}: ${2} = ${3};

snippet letm "let mut"
	let mut ${1} = ${2};

snippet lettm "let mut typed"
	let mut ${1}: ${2} = ${3};

snippet pri "print!"
	print!("${1}");

snippet pln "println!"
	println!("${1}");

snippet fmt "format!"
	format!("${1}{${2}}", ${3});

snippet d "dbg!"
	dbg!(${0})

snippet d; "dbg! with ref"
	dbg!(&${1});
	${0}

snippet ec "extern crate"
	extern crate ${1};

snippet ecl "extern crate log"
	#[macro_use]
	extern crate log;

snippet mod "mod"
	mod ${1} {
		${0}
	} /* ${1} */

snippet as "assert!"
	assert!(${1:predicate});

snippet ase "assert_eq!"
	assert_eq!(${1:expected}, ${2:actual});

snippet test "test"
	#[test]
	fn ${1}_test() {
		${0}
	}

snippet testmod "test module"
	#[cfg(test)]
	mod tests {
		use super::*;

		test${0}
	}

snippet ig "ignore"
	#[ignore]

snippet allow "allow"
	#[allow(${1:unused_variables})]

snippet cfg "cfg"
	#[cfg(${1:target_os = "linux"})]

snippet feat "feature"
	#![feature(${1})]

snippet der "derive"
	#[derive(${1:Debug})]

snippet attr "attribute"
	#[${1:inline}]

snippet crate "crate header"
	// Crate name
	#![crate_name = "${1:crate_name}"]
	// Additional metadata attributes
	#![desc = "${2:Descrption.}"]
	#![license = "${3:MIT}"]
	#![comment = "${4:Comment.}"]
	// Specify the output type
	#![crate_type = "${5:lib}"]

snippet opt "Option"
	Option<${1:i32}>

snippet res "Result"
	Result<${1:~str}, ${2:()}>

snippet if "if"
	if ${1} {
		${0}
	}

snippet ife "if else"
	if ${1} {
		${0}
	} else {
		${2}
	}

snippet ifl "if let"
	if let ${1:Some($2)} = ${3} {
		${0}
	}

snippet el "else"
	else {
		${0}
	}

snippet eli "else if"
	else if ${1} {
		${0}
	}

snippet mat "match"
	match ${1} {
		${2} => ${3}
	}

snippet case "match case"
	${1:_} => ${2:expression}

snippet = "=>"
	=> ${0}

snippet loop "loop"
	loop {
		${0}
	}

snippet wh "while"
	while ${1:condition} {
		${0}
	}

snippet whl "while let"
	while let ${1:Some($2)} = ${3} {
		${0}
	}

snippet for "for"
	for ${1:i} in ${2} {
		${0}
	}

snippet st "struct"
	struct ${1} {
		${0}
	}

snippet impl "impl"
	impl ${1:Type/Trait}${2: for $3} {
		${0}
	}

snippet stn "struct with new"
	pub struct ${1} {
		${0}
	}

	impl ${1} {
		pub fn new(${4}) -> Self {
			${1} { ${5} }
		}
	}

snippet ty "type"
	type ${1:NewName} = ${2}

snippet enum "enum"
	enum ${1:Name} {
		${2},
	}

snippet penum "pub enum"
	pub enum ${1:Name} {
		${2},
	}

snippet trait "trait"
	trait ${1:Name} {
		${0}
	}

snippet drop "impl Drop"
	impl Drop for ${1} {
		fn drop(&mut self) {
			${0}
		}
	}

snippet ss "static str"
	static ${1}: &'static str = "${0}";

snippet stat "static"
	static ${1}: ${2:usize} = ${0};

snippet scoped "thread scoped"
	thread::scoped(${1:move }|| {
		${0}
	});

snippet spawn "thread spawn"
	thread::spawn(${1:move }|| {
		${0}
	});

snippet chan "channel"
	let (${1:tx}, ${2:rx}): (Sender<${3:i32}>, Receiver<${4:i32}>) = channel();

snippet asref "impl AsRef"
	impl AsRef<${1:Ref}> for ${2:Type} {
		fn as_ref(&self) -> &${3:$1} {
			&self.${0:field}
		}
	}

snippet asmut "impl AsMut"
	impl AsMut<${1:Ref}> for ${2:Type} {
		fn as_mut(&mut self) -> &mut ${3:$1} {
			&mut self.${0:field}
		}
	}

snippet fd "field"
	${1:name}: ${2:Type},

snippet || "closure"
	${1:move }|${2}| { ${3} }

snippet |} "closure block"
	${1:move }|${2}| {
		${3}
	}

snippet macro "macro_rules!"
	macro_rules! ${1:name} {
		(${2:matcher}) => (
			${3}
		)
	}

snippet boxp "Box::new"
	Box::new(${0})

snippet rc "Rc::new"
	Rc::new(${0})

snippet unim "unimplemented!"
	unimplemented!()

snippet use "use"
	use ${1:std::${2}};
